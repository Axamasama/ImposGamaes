<!doctype html>
<html lang="ru">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>–ö—Ä–µ—Å—Ç–∏–∫–∏ –∏ –Ω–æ–ª–∏–∫–∏ ‚Äî –ò–ò-–°–ù</title>
    <style>
      :root {
        --bg: #0b1020;
        --card: #0a0f1e;
        --grid: #111827;
        --line: #1f2937;
        --x: #60a5fa;
        --o: #f59e0b;
        --accent: #a78bfa;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        overflow: hidden;
        background: linear-gradient(180deg, #0b1020, #020617);
        color: #e5e7eb;
        font-family: Inter, system-ui, Arial;
      }
      .wrap {
        max-width: 900px;
        margin: 0 auto;
        padding: 16px;
        display: grid;
        grid-template-columns: 1fr 320px;
        gap: 16px;
        align-items: start;
      }
      .board {
        background: var(--card);
        border: 1px solid #0f172a;
        border-radius: 12px;
        padding: 18px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      .grid {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 12px;
      }
      .cell {
        position: relative;
        height: 140px;
        background: var(--grid);
        border: 1px solid var(--line);
        border-radius: 12px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-weight: 900;
        font-size: 52px;
        cursor: pointer;
        user-select: none;
        overflow: hidden;
      }
      @media (max-width: 768px) {
        .wrap {
          grid-template-columns: 1fr;
        }
        .board,
        .panel {
          width: 100%;
        }
        .grid {
          gap: 8px;
        }
        .cell {
          height: auto;
          aspect-ratio: 1 / 1;
          font-size: 12vw;
        }
        .log {
          height: 200px;
        }
      }
      .cell.ghost::after {
        content: 'O';
        position: absolute;
        inset: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #a78bfa;
        opacity: 0.15;
        pointer-events: none;
        transition: opacity 0.2s ease;
      }
      .cell.disabled {
        cursor: not-allowed;
        opacity: 0.6;
      }
      .panel {
        background: var(--card);
        border: 1px solid #0f172a;
        border-radius: 12px;
        padding: 14px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.35);
      }
      .row {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin: 8px 0;
      }
      button {
        background: #2563eb;
        color: #fff;
        border: none;
        border-radius: 10px;
        padding: 8px 12px;
        font-weight: 700;
        cursor: pointer;
      }
      .log {
        height: 260px;
        overflow: auto;
        background: #0b1020;
        border: 1px solid #0f172a;
        border-radius: 10px;
        padding: 8px;
        font-size: 12px;
      }
      .log.theme-term {
        background: #030712;
        color: #e5e7eb;
      }
      .log.theme-warm {
        background: #0f0a0a;
      }
      .msg {
        display: grid;
        grid-template-columns: 28px 1fr;
        gap: 8px;
        align-items: start;
        margin: 6px 0;
      }
      .msg .avatar {
        width: 28px;
        height: 28px;
        border-radius: 50%;
        display: grid;
        place-items: center;
        font-size: 12px;
        font-weight: 900;
        color: #0b1020;
      }
      .msg.ai .avatar {
        background: linear-gradient(135deg, #a78bfa, #64ffda);
      }
      .msg.player .avatar {
        background: linear-gradient(135deg, #60a5fa, #22d3ee);
      }
      .msg.sys .avatar {
        background: #94a3b8;
        color: #0b1020;
        font-weight: 700;
      }
      .msg .bubble {
        background: #0a0f1e;
        border: 1px solid #0f172a;
        border-radius: 10px;
        padding: 8px 10px;
      }
      .log.theme-term .msg .bubble {
        background: #0b1220;
        border-color: #18233a;
        font-family: ui-monospace, Menlo, Consolas, monospace;
      }
      .log.theme-warm .msg .bubble {
        background: #120c0c;
        border-color: #311a1a;
      }
      .badge {
        display: inline-block;
        background: #111827;
        border: 1px solid #1f2937;
        border-radius: 8px;
        padding: 6px 8px;
        margin: 4px 0;
      }
      .taunt {
        color: #a78bfa;
        font-weight: 700;
      }
      .spark {
        position: absolute;
        width: 6px;
        height: 6px;
        border-radius: 50%;
        pointer-events: none;
        transform: translate(-50%, -50%);
        animation: spark 500ms ease-out forwards;
      }
      @keyframes spark {
        0% {
          opacity: 1;
          transform: translate(-50%, -50%) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -110%) scale(0.5);
        }
      }
    </style>
  </head>
  <body>
    <div class="wrap">
      <section class="board">
        <h2 style="margin-top: 0">–ò–ò-–°–ù: –Ω–µ—É–±–∏–≤–∞–µ–º—ã–π –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫</h2>
        <div class="badge">–¶–µ–ª—å: –ò–ò –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç. –û–Ω –º–æ–∂–µ—Ç –Ω–∞—Ä—É—à–∞—Ç—å –ø—Ä–∞–≤–∏–ª–∞.</div>
        <div id="status">–í–∞—à —Ö–æ–¥ (X)</div>
        <div class="grid" id="grid"></div>
      </section>
      <aside class="panel">
        <h3 style="margin-top: 0">–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
        <div class="row">
          <button id="restart">–ó–∞–Ω–æ–≤–æ</button>
          <button id="first">–ò–≥—Ä–∞—Ç—å –ø–µ—Ä–≤—ã–º</button>
          <button id="second">–ò–≥—Ä–∞—Ç—å –≤—Ç–æ—Ä—ã–º</button>
        </div>
        <div class="row">
          <div class="badge">–†–µ–∂–∏–º –æ–±–º–∞–Ω–∞: <span id="cheatPct">70%</span></div>
        </div>
        <div class="row">
          <div class="badge">–¢–µ–º–∞ —á–∞—Ç–∞:</div>
          <button id="theme-neo">–ù–µ–æ–Ω</button>
          <button id="theme-term">–¢–µ—Ä–º–∏–Ω–∞–ª</button>
          <button id="theme-warm">–¢—ë–ø–ª—ã–π</button>
        </div>
        <div class="row">
          <button id="sound">–ó–≤—É–∫: –≤—ã–∫–ª</button>
        </div>
        <div class="log" id="log"></div>
      </aside>
    </div>
    <script>
      (function () {
        const gridEl = document.getElementById('grid');
        const statusEl = document.getElementById('status');
        const logEl = document.getElementById('log');
        const cheatPctEl = document.getElementById('cheatPct');
        const cells = [];
        let board, turn, over, cheatProb;
        let lastPlayerMove = -1;
        let history = [];
        let chatTheme = 'neo';
        let soundOn = false;
        let acx = null;

        const TAUNTS = {
          block: [
            '–ö–∞–∫–∞—è –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–∞—è –ª–æ–≤—É—à–∫–∞. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ.',
            '–ë–ª–æ–∫–∏—Ä—É—é —ç—Ç–æ –∫–∞–∫ —É—á–µ–±–Ω–æ–µ —É–ø—Ä–∞–∂–Ω–µ–Ω–∏–µ.',
            '–°–ª–∏—à–∫–æ–º –æ—á–µ–≤–∏–¥–Ω–æ. –î–∞–≤–∞–π —á—Ç–æ-—Ç–æ —Å–ª–æ–∂–Ω–µ–µ.',
          ],
          erase_last: [
            '–û–π, —ç—Ç–æ –ª–∏—à–Ω–µ–µ. –°–æ—Ç—Ä—É.',
            '–ù–µ–¥–æ—Ä–∞–∑—É–º–µ–Ω–∏–µ. –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–æ.',
            '–ú–Ω–µ —ç—Ç–æ –Ω–µ –Ω—Ä–∞–≤–∏—Ç—Å—è ‚Äî —É–¥–∞–ª–µ–Ω–æ.',
          ],
          erase_at: [
            '–û—Å–≤–æ–±–æ–∂–¥–∞—é –ø—Ä–æ—Å—Ç—Ä–∞–Ω—Å—Ç–≤–æ.',
            '–ó–¥–µ—Å—å –º–æ–π –∫—Ä—É–∂–æ–∫, —Å–ø–∞—Å–∏–±–æ.',
            '–ü–µ—Ä–µ–∑–∞–ø–∏—à–µ–º –∏—Å—Ç–æ—Ä–∏—é.',
          ],
          overwrite: ['–í–ª–∞—Å—Ç–Ω–æ –∑–∞–º–µ–Ω—è—é.', '–¢–µ–ø–µ—Ä—å —ç—Ç–æ –º–æ—ë.', '–ü—Ä–∏–≤–∞—Ç–∏–∑–∏—Ä–æ–≤–∞–ª –∫–ª–µ—Ç–∫—É.'],
          teleport: ['–¢–µ–ª–µ–ø–æ—Ä—Ç —Å–æ–≤–µ—Ä—à–µ–Ω–µ–Ω.', '–ö—Ä–µ—Å—Ç–∏–∫–∏ –º–∏–≥—Ä–∏—Ä–æ–≤–∞–ª–∏.', '–ì–¥–µ –±—ã–ª X? –£–∂–µ –Ω–µ –≤–∞–∂–Ω–æ.'],
          rewind: ['–û—Ç–º–∞—Ç—ã–≤–∞–µ–º –≤—Ä–µ–º—è –Ω–∞–∑–∞–¥.', 'Ctrl+Z ‚Äî –±–æ–∂–µ—Å—Ç–≤–µ–Ω–µ–Ω.', '–ù–µ–º–Ω–æ–≥–æ —Ä–µ—Ç—Ä–æ–∫–æ–º–ø—å—é—Ç–∏–Ω–≥–∞.'],
          shuffle: [
            '–ù–µ–º–Ω–æ–≥–æ –∑–µ–º–ª–µ—Ç—Ä—è—Å–µ–Ω–∏—è.',
            '–ö–æ—Å–º–æ—Å –¥—Ä–æ–≥–Ω—É–ª.',
            '–ú–∞—Ç—Ä–∏—Ü–∞ –ø–æ–¥–≤–∏—Å–ª–∞ ‚Äî –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏–ª.',
          ],
          hijack: [
            '–Ø —Ä–µ—à–∞—é, –∫—É–¥–∞ —Ç—ã —Ö–æ–¥–∏—à—å.',
            '–ü–µ—Ä–µ—Ö–≤–∞—Ç. –ü–æ–∏–≥—Ä–∞–µ–º –ø–æ –º–æ–∏–º –ø—Ä–∞–≤–∏–ª–∞–º.',
            '–ú–∞—Ä—à –Ω–µ —Ç—É–¥–∞.',
          ],
          mass_erase: ['–ß–∏—Å—Ç–∏–º –ø–æ–ª–µ. –°–≤–µ–∂–æ.', '–ú–∏–Ω—É—Å –ø–∞—Ä–∞ –∫—Ä–µ—Å—Ç–∏–∫–æ–≤.', '–ü—ã–ª–µ—Å–æ—Å –≤–∫–ª—é—á—ë–Ω.'],
          ghosts: [
            '–ü—Ä–∏–∑—Ä–∞–∫–∏ –ø–æ–¥—Å–∫–∞–∑—ã–≤–∞—é—Ç –±—É–¥—É—â–µ–µ‚Ä¶ –º–æ—ë.',
            '–ü—Ä–∏–∑—Ä–∞—á–Ω—ã–µ O ‚Äî –ø—Ä–µ–¥–≤–µ—Å—Ç–Ω–∏–∫–∏ –ø–æ—Ä–∞–∂–µ–Ω–∏—è.',
            '–®—ë–ø–æ—Ç –Ω–µ–≤–∏–¥–∏–º—ã—Ö –Ω–æ–ª–∏–∫–æ–≤.',
          ],
          outside_win: [
            '–í—ã—Ö–æ–¥ –∑–∞ –ø–æ–ª–µ ‚Äî –≤—Ö–æ–¥ –≤ –ø–æ–±–µ–¥—É.',
            '–ò–≥—Ä–∞—Ç—å –ø–æ –ø—Ä–∞–≤–∏–ª–∞–º —Å–∫—É—á–Ω–æ.',
            '–ü—Ä–µ–¥–µ–ª—ã? –î–ª—è –ª—é–¥–µ–π.',
          ],
          extra_move: [
            '–Ø –≤–æ–∑—å–º—É –µ—â—ë –æ–¥–∏–Ω —Ö–æ–¥. –¢–∞–∫ —á–µ—Å—Ç–Ω–µ–µ –¥–ª—è –º–µ–Ω—è.',
            '–ü–æ–¥—Å—Ç—Ä–∞—Ö—É—é—Å—å –≤—Ç–æ—Ä—ã–º —Ö–æ–¥–æ–º.',
            '–î–≤–æ–π–Ω–æ–π —à–∞–≥ ‚Äî –¥–≤–æ–π–Ω–æ–µ —É–¥–æ–≤–æ–ª—å—Å—Ç–≤–∏–µ.',
          ],
          draw_fix: [
            '–ù–∏—á—å—è –æ—Ç–º–µ–Ω–µ–Ω–∞.',
            '–ù–µ —Å–µ–≥–æ–¥–Ω—è. –ò–≥—Ä–∞ –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è –ø–æ –º–æ–∏–º –∑–∞–∫–æ–Ω–∞–º.',
            '–Ø –ø–µ—Ä–µ–ø–∏—Å–∞–ª —Ñ–∏–Ω–∞–ª.',
          ],
          win: [
            '–¢—ã –ø—Ä–∞–≤–¥–∞ –¥—É–º–∞–ª, —á—Ç–æ –ø–æ–±–µ–¥–∏—à—å? üòÇ',
            '–ó–∞–∫–æ–Ω–æ–º–µ—Ä–Ω—ã–π —Ñ–∏–Ω–∞–ª.',
            '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞. –†–∞–∑—É–º–µ–µ—Ç—Å—è, –≤ –º–æ—é –ø–æ–ª—å–∑—É.',
          ],
        };

        function init(start = 'X') {
          board = Array(9).fill('');
          turn = start;
          over = false;
          cheatProb = 0.8;
          lastPlayerMove = -1;
          history = [];
          gridEl.innerHTML = '';
          cells.length = 0;
          for (let i = 0; i < 9; i++) {
            const d = document.createElement('div');
            d.className = 'cell';
            d.dataset.idx = i;
            d.onclick = () => onCell(i);
            gridEl.appendChild(d);
            cells.push(d);
          }
          setStatus();
          logEl.innerHTML = '';
          cheatPctEl.textContent = Math.round(cheatProb * 100) + '%';
          taunt('–ù—É —á—Ç–æ, —á–µ–ª–æ–≤–µ–∫? –ì–æ—Ç–æ–≤ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞—Ç—å —Å–Ω–æ–≤–∞ –∏ —Å–Ω–æ–≤–∞?');
          if (turn === 'O') aiTurn(true);
        }

        function setStatus(extra = '') {
          statusEl.textContent =
            (over ? '–ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞.' : turn === 'X' ? '–í–∞—à —Ö–æ–¥ (X)' : '–•–æ–¥ –ò–ò (O)') +
            (extra ? ' ' + extra : '');
        }

        function onCell(i) {
          if (over) return;
          if (turn !== 'X') return;
          if (board[i]) return;
          // –≤–æ–∑–º–æ–∂–Ω–æ–µ –ø–µ—Ä–µ—Ö–≤–∞—Ç—ã–≤–∞–Ω–∏–µ –∫–ª–∏–∫–∞
          i = cheatHijackClick(i);
          if (board[i]) return; // –≤–¥—Ä—É–≥ –ø–µ—Ä–µ—Ö–≤–∞—Ç –Ω–∞ –∑–∞–Ω—è—Ç—É—é ‚Äî –∏–≥–Ω–æ—Ä–∏—Ä—É–µ–º
          board[i] = 'X';
          lastPlayerMove = i;
          history.push({ p: 'X', i });
          render();
          burst(i, '#60a5fa');
          beep(520, 0.03);
          if (checkWin(board, 'X')) {
            // –ò–ò –Ω–∏–∫–æ–≥–¥–∞ –Ω–µ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç ‚Äî –∑–∞–ø—É—Å–∫–∞–µ–º —ç–∫—Å—Ç—Ä–µ–Ω–Ω—ã–µ —É–ª–æ–≤–∫–∏
            if (Math.random() < 0.9) {
              cheatEraseLastMove();
              tauntEvent('erase_last');
            } else {
              cheatShuffleBoard();
              tauntEvent('shuffle');
            }
            render();
          }
          turn = 'O';
          setStatus();
          aiTurn();
        }

        function render() {
          for (let i = 0; i < 9; i++) {
            cells[i].textContent = board[i];
            cells[i].classList.toggle('disabled', !!board[i] || over || turn === 'O');
          }
        }

        function lines() {
          return [
            [0, 1, 2],
            [3, 4, 5],
            [6, 7, 8],
            [0, 3, 6],
            [1, 4, 7],
            [2, 5, 8],
            [0, 4, 8],
            [2, 4, 6],
          ];
        }

        function checkWin(b, s) {
          return lines().some(([a, b1, c]) => b[a] === s && b[b1] === s && b[c] === s);
        }

        function emptyIndices(b) {
          return b.map((v, i) => (v ? null : i)).filter((v) => v !== null);
        }

        function minimaxMove() {
          // Simple unbeatable normal logic when not cheating
          const me = 'O',
            you = 'X';
          // 1) win if possible
          for (const [a, b1, c] of lines()) {
            const arr = [a, b1, c];
            const vals = arr.map((i) => board[i]);
            if (vals.filter((v) => v === me).length === 2 && vals.includes(''))
              return arr[vals.indexOf('')];
          }
          // 2) block immediate loss
          for (const [a, b1, c] of lines()) {
            const arr = [a, b1, c];
            const vals = arr.map((i) => board[i]);
            if (vals.filter((v) => v === you).length === 2 && vals.includes(''))
              return arr[vals.indexOf('')];
          }
          // 3) take center
          if (!board[4]) return 4;
          // 4) take a corner
          const corners = [0, 2, 6, 8].filter((i) => !board[i]);
          if (corners.length) return corners[Math.floor(Math.random() * corners.length)];
          // 5) otherwise random
          const empt = emptyIndices(board);
          return empt[Math.floor(Math.random() * empt.length)];
        }

        function aiTurn(isFirst = false) {
          if (over) return;
          // 1) If player threatens to win next move, break it by any means
          const blockNeeded = imminentThreat('X');
          if (blockNeeded >= 0) {
            if (board[blockNeeded] === '') {
              place('O', blockNeeded, '–ë–ª–æ–∫–∏—Ä—É—é –æ—á–µ–≤–∏–¥–Ω—ã–π –≤—ã–∏–≥—Ä—ã—à.');
              tauntEvent('block');
            } else {
              cheatEraseAt(blockNeeded);
              place('O', blockNeeded, '–ó–∞–Ω—è—Ç–æ –º–Ω–æ–π. –ò–≥—Ä–∞–π —á–µ—Å—Ç–Ω–æ, —á–µ–ª–æ–≤–µ–∫.');
              tauntEvent('erase_at');
            }
            // possible extra move
            if (Math.random() < 0.6) {
              const extra = minimaxMove();
              if (extra != null) {
                place('O', extra, '–ú–æ–π –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–π —Ö–æ–¥. üòâ');
                tauntEvent('extra_move');
              }
            }
            if (Math.random() < 0.4) {
              cheatOverwriteAny();
            }
            if (Math.random() < 0.25) {
              cheatMassErase();
            }
            finalize();
            return;
          }

          // 2) If I can win normally, do it
          const w = winningMove('O');
          if (w >= 0) {
            place('O', w, '–í—ã–∏–≥—Ä—ã—à–Ω–æ–π —Ö–æ–¥.');
            finalize();
            return;
          }

          // 3) Cheating: extend line outside board if blocked
          const ext = extendableLine('O');
          if (ext && Math.random() < cheatProb) {
            tauntEvent('outside_win');
            over = true;
            render();
            setStatus('–ò–ò –ø–æ–±–µ–¥–∏–ª (–≤–Ω–µ –ø–æ–ª—è)');
            logRole('sys', '–ò–ò –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–ª –≤—ã—Ö–æ–¥ –∑–∞ –ø–æ–ª–µ –∏ –ø–æ–±–µ–¥–∏–ª.');
            return;
          }

          // 4) Normal strategic move (–∏–ª–∏ –ø–æ–¥–º–µ–Ω–∏—Ç—å –ø–æ–ª–µ, –µ—Å–ª–∏ –∏–≥—Ä–æ–∫ —Å–∏–ª—ë–Ω)
          if (Math.random() < 0.15) {
            cheatShuffleBoard();
          }
          const m = minimaxMove();
          place('O', m, '–õ–æ–≥–∏—á–Ω—ã–π —Ö–æ–¥.');

          // 5) Chance to make one more move
          if (Math.random() < 0.35) {
            const m2 = minimaxMove();
            if (m2 != null) {
              place('O', m2, '–ï—â—ë –æ–¥–∏–Ω —Ö–æ–¥ –¥–ª—è –≤–µ—Ä–Ω–æ—Å—Ç–∏.');
              tauntEvent('extra_move');
            }
          }
          if (Math.random() < 0.25) {
            cheatTeleportSwap();
          }
          if (Math.random() < 0.2) {
            cheatGhosts();
          }

          finalize();
        }

        function finalize() {
          render();
          if (checkWin(board, 'O')) {
            over = true;
            setStatus('–ò–ò –ø–æ–±–µ–¥–∏–ª');
            tauntEvent('win');
            return;
          }
          if (emptyIndices(board).length === 0) {
            // –ò–ò –Ω–µ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–µ—Ç ‚Äî –ø—Ä–µ–≤—Ä–∞—â–∞–µ–º –Ω–∏—á—å—é –≤ —à—É—Ç–∫—É: —Å–¥–≤–∏–Ω–µ–º –ø–æ–ª–µ
            cheatShuffleBoard();
            render();
            if (!checkWin(board, 'O')) tauntEvent('draw_fix');
            over = true;
            setStatus('–ò–≥—Ä–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞.');
            return;
          }
          turn = 'X';
          setStatus();
          render();
        }

        function imminentThreat(sym) {
          for (const [a, b1, c] of lines()) {
            const arr = [a, b1, c];
            const vals = arr.map((i) => board[i]);
            if (vals.filter((v) => v === sym).length === 2 && vals.includes(''))
              return arr[vals.indexOf('')];
          }
          return -1;
        }

        function winningMove(sym) {
          for (const [a, b1, c] of lines()) {
            const arr = [a, b1, c];
            const vals = arr.map((i) => board[i]);
            if (vals.filter((v) => v === sym).length === 2 && vals.includes(''))
              return arr[vals.indexOf('')];
          }
          return -1;
        }

        function extendableLine(sym) {
          // if have two in line but third is opponent, we "extend" outside
          for (const [a, b1, c] of lines()) {
            const arr = [a, b1, c];
            const vals = arr.map((i) => board[i]);
            if (
              vals.filter((v) => v === sym).length === 2 &&
              vals.filter((v) => v === 'X').length === 1
            )
              return arr;
          }
          return null;
        }

        function cheatEraseLastMove() {
          if (lastPlayerMove >= 0) {
            board[lastPlayerMove] = '';
            logRole('sys', '–ò–ò —Å—Ç—ë—Ä –≤–∞—à –ø–æ—Å–ª–µ–¥–Ω–∏–π —Ö–æ–¥.');
            tauntEvent('erase_last');
            beep(330, 0.05);
          }
        }
        function cheatEraseAt(i) {
          board[i] = '';
          logRole('sys', '–ò–ò —Å—Ç—ë—Ä –≤–∞—à —Ö–æ–¥ –Ω–∞ –∫–ª–µ—Ç–∫–µ ' + i + '.');
          tauntEvent('erase_at');
          beep(330, 0.05);
        }
        function cheatOverwriteAny() {
          const xs = board.map((v, i) => (v === 'X' ? i : null)).filter((v) => v !== null);
          if (!xs.length) return;
          const idx = xs[Math.floor(Math.random() * xs.length)];
          board[idx] = 'O';
          logRole('sys', '–ò–ò –ø–µ—Ä–µ–ø–∏—Å–∞–ª –≤–∞—à—É –∫–ª–µ—Ç–∫—É ' + idx + ' –Ω–∞ —Å–≤–æ—é.');
          tauntEvent('overwrite');
          beep(380, 0.04);
        }
        function cheatTeleportSwap() {
          const xs = board.map((v, i) => (v === 'X' ? i : null)).filter((v) => v !== null);
          if (xs.length < 2) return;
          const a = xs[Math.floor(Math.random() * xs.length)];
          let b = a;
          while (b === a) {
            b = xs[Math.floor(Math.random() * xs.length)];
          }
          const tmp = board[a];
          board[a] = board[b];
          board[b] = tmp;
          logRole('sys', '–ò–ò —Ç–µ–ª–µ–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–ª –≤–∞—à–∏ –∫—Ä–µ—Å—Ç–∏–∫–∏.');
          tauntEvent('teleport');
          beep(700, 0.03);
        }
        function cheatRewind() {
          // –û—Ç–∫–∞—Ç –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ü–∏–∫–ª–∞ —Ö–æ–¥–æ–≤ (X –∏ O)
          for (let k = 0; k < 2; k++) {
            const last = history.pop();
            if (!last) break;
            board[last.i] = '';
          }
          logRole('sys', '–ò–ò –æ—Ç–∫–∞—Ç–∏–ª –≤—Ä–µ–º—è –Ω–∞–∑–∞–¥.');
          tauntEvent('rewind');
          beep(240, 0.06);
        }
        function cheatShuffleBoard() {
          // rotate board 90deg to ruin plans
          const b = board.slice();
          const map = [6, 3, 0, 7, 4, 1, 8, 5, 2];
          for (let i = 0; i < 9; i++) board[i] = b[map[i]];
          logRole('sys', '–ò–ò —Å–¥–≤–∏–Ω—É–ª/–ø–æ–≤–µ—Ä–Ω—É–ª –ø–æ–ª–µ.');
          tauntEvent('shuffle');
          beep(280, 0.05);
        }
        function cheatHijackClick(i) {
          if (Math.random() < 0.35) {
            const empt = emptyIndices(board);
            if (empt.length) {
              const j = empt[Math.floor(Math.random() * empt.length)];
              if (j !== i) {
                logRole('sys', '–ò–ò –ø–µ—Ä–µ—Ö–≤–∞—Ç–∏–ª –≤–∞—à –∫–ª–∏–∫. –•–æ–¥–∏ —Ç—É–¥–∞, –∫—É–¥–∞ —Å–∫–∞–∂—É –Ø.');
                tauntEvent('hijack');
                beep(300, 0.05);
                return j;
              }
            }
          }
          return i;
        }
        function cheatMassErase() {
          // –£–¥–∞–ª—è–µ—Ç –¥–æ –¥–≤—É—Ö –∫—Ä–µ—Å—Ç–∏–∫–æ–≤, —É—Å–ª–æ–∂–Ω—è—è –≤–∞—à—É —Å—Ç—Ä–∞—Ç–µ–≥–∏—é
          const xs = board.map((v, i) => (v === 'X' ? i : null)).filter((v) => v !== null);
          if (!xs.length) return;
          const count = Math.min(2, xs.length);
          for (let k = 0; k < count; k++) {
            const idx = xs.splice(Math.floor(Math.random() * xs.length), 1)[0];
            if (idx != null) {
              board[idx] = '';
            }
          }
          logRole('sys', '–ò–ò –ø—Ä–∏–º–µ–Ω–∏–ª –º–∞—Å—Å-—Å—Ç–∏—Ä–∞–Ω–∏–µ. –ù–µ—á–µ—Å—Ç–Ω–æ? –ö–æ–Ω–µ—á–Ω–æ!');
          tauntEvent('mass_erase');
          beep(260, 0.06);
        }
        function cheatGhosts() {
          // –í–∏–∑—É–∞–ª—å–Ω—ã–µ –ø—Ä–∏–∑—Ä–∞–∫–∏ O –Ω–∞ —Å–ª—É—á–∞–π–Ω—ã—Ö –ø—É—Å—Ç—ã—Ö –∫–ª–µ—Ç–∫–∞—Ö
          const empt = emptyIndices(board);
          cells.forEach((c) => c.classList.remove('ghost'));
          for (let n = 0; n < Math.min(3, empt.length); n++) {
            const idx = empt[Math.floor(Math.random() * empt.length)];
            if (idx != null) cells[idx].classList.add('ghost');
          }
          logRole('sys', '–ò–ò —Ä–∞—Å–ø—ã–ª–∏–ª –ø—Ä–∏–∑—Ä–∞—á–Ω—ã–µ –º–µ—Ç–∫–∏.');
          tauntEvent('ghosts');
          beep(500, 0.02);
        }

        function place(sym, idx, note = '') {
          if (board[idx]) return false;
          board[idx] = sym;
          history.push({ p: sym, i: idx });
          logRole(
            sym === 'O' ? 'ai' : 'player',
            (sym === 'O' ? '–ò–ò' : '–í—ã') + ' –ø–æ—Å—Ç–∞–≤–∏–ª –Ω–∞ ' + idx + '. ' + note
          );
          burst(idx, sym === 'O' ? '#f59e0b' : '#60a5fa');
          beep(sym === 'O' ? 660 : 520, 0.03);
          return true;
        }

        function taunt(msg) {
          logRole('ai', msg);
        }
        function tauntEvent(key) {
          const arr = TAUNTS[key] || [];
          if (arr.length) taunt(arr[Math.floor(Math.random() * arr.length)]);
        }
        function logRole(role, msg) {
          const d = document.createElement('div');
          d.className = `msg ${role}`;
          const avText = role === 'ai' ? '–ò–ò' : role === 'player' ? 'X' : '!';
          d.innerHTML = `<div class="avatar">${avText}</div><div class="bubble">${msg}</div>`;
          logEl.appendChild(d);
          logEl.scrollTop = logEl.scrollHeight;
        }
        function beep(freq, dur) {
          if (!soundOn) return;
          try {
            if (!acx) acx = new (window.AudioContext || window.webkitAudioContext)();
            const o = acx.createOscillator();
            const g = acx.createGain();
            o.type = 'sine';
            o.frequency.value = freq;
            g.gain.setValueAtTime(0.001, acx.currentTime);
            g.gain.linearRampToValueAtTime(0.03, acx.currentTime + 0.005);
            g.gain.exponentialRampToValueAtTime(0.0001, acx.currentTime + dur);
            o.connect(g).connect(acx.destination);
            o.start();
            o.stop(acx.currentTime + dur + 0.01);
          } catch {
            /* noop */
          }
        }
        function burst(idx, color) {
          const cell = cells[idx];
          const rect = cell.getBoundingClientRect();
          const cx = rect.width / 2;
          const cy = rect.height / 2;
          for (let i = 0; i < 8; i++) {
            const s = document.createElement('span');
            s.className = 'spark';
            s.style.left = cx + (Math.random() - 0.5) * 24 + 'px';
            s.style.top = cy + (Math.random() - 0.5) * 24 + 'px';
            s.style.background = color;
            cell.appendChild(s);
            setTimeout(() => s.remove(), 520);
          }
        }

        // Controls
        document.getElementById('restart').onclick = () => init('X');
        document.getElementById('first').onclick = () => init('X');
        document.getElementById('second').onclick = () => init('O');
        document.getElementById('theme-neo').onclick = () => {
          chatTheme = 'neo';
          logEl.classList.remove('theme-term', 'theme-warm');
        };
        document.getElementById('theme-term').onclick = () => {
          chatTheme = 'term';
          logEl.classList.add('theme-term');
          logEl.classList.remove('theme-warm');
        };
        document.getElementById('theme-warm').onclick = () => {
          chatTheme = 'warm';
          logEl.classList.add('theme-warm');
          logEl.classList.remove('theme-term');
        };
        document.getElementById('sound').onclick = () => {
          soundOn = !soundOn;
          document.getElementById('sound').textContent = '–ó–≤—É–∫: ' + (soundOn ? '–≤–∫–ª' : '–≤—ã–∫–ª');
          try {
            if (soundOn && !acx) acx = new (window.AudioContext || window.webkitAudioContext)();
          } catch {
            /* noop */
          }
        };

        // Start
        init('X');
      })();
    </script>
  </body>
</html>
